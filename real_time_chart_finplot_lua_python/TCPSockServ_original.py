import socket
import threading

client = None


# Пример TCP сокет-сервера на порту 3599 с постоянным прослушиванием. Клиент подсоединяется один раз и передает
# данные когда угодно. В примере от клиента приходят строки, разделенные символом \n,
# информация в строках разделена пробелами
def service():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('127.0.0.1', 3599))  # Запускаем сервер на локальной машине, порт 3599
    s.listen(5)  # Начинаем прослушивать
    # Принимаем соединения с помощью функции accept. Она ждёт появления входящего соединения и
    # возвращает связанный с ним сокет и адрес подключившегося. Адрес — массив, состоящий из IP-адреса и порта.
    conn, addr = s.accept()
    global client
    client = conn
    tail = b''  # Не уместившееся полностью в буфер сообщение от клиента. В начале - пустая строка.
    while True:  # "вечный" цикл, пока клиент не "отвалится"
        data = conn.recv(1024)  # Принимаем в буфер data(1024 байт) сообщения от клиента
        if not data:  # Если клиент закрыл сокет,
            conn.close()  # то сервер закрывает это соединение и выходит из цикла
            break
        else:
            # Хотя клиент и отсылает сообщения по одному, разделяя их символом \n, но если идет большой поток сообщений
            # в цикле, то в буфер могут попасть несколько сообщений одновременно
            messages = data.splitlines()  # по-этому, разделяем сообщения в буфере на строки
            # Если на момент обработки буфера присутствует "хвост" от прошлого сообщения
            # (т.е. оно не уместилось целиком в буфере),
            messages[0] = tail + messages[0]  # добавляем его в начало первого сообщения в буфере
            # Если последним элементом в буфере является символ новой строки \n, то все сообщения уместились в буфере
            if data[-1] == 10:  # 10 - это байт-код символа новой строки \n
                tail = b''  # В этом случае "хвостов" не осталось
            else:  # а если сообщение не уместилось в буфер,
                tail = messages[-1]  # то сохраняем этот кусок(последний элемент) как tail
                messages = messages[:-1]  # а сами сообщения сохраняем, но без последнего "обрезка"
            # С этого места можно обрабатывать список сообщений от клиента с гарантией,
            # что все сообщения целы и не обрезаны буфером
            print('Clear:', messages)
            for m in messages:
                mess = m.decode()  # переводим из бинарной кодировки в utf8
                print(mess)
    conn.close()  # если клиент закрыл соединение то и мы закрываем соединение
    s.close()


# Запускаем сервер в своем потоке
t = threading.Thread(name='service', target=service)
t.start()
